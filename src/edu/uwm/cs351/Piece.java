package edu.uwm.cs351;

import java.awt.Graphics;
import java.awt.Point;
import java.util.AbstractCollection;
import java.util.ConcurrentModificationException;
import java.util.Iterator;
import java.util.NoSuchElementException;

import javax.swing.Icon;

import junit.framework.TestCase;

/**
 * A piece in a game using hexagonal boards.
 * It uses the {@link Rank} to determine kind of piece.
 */
public class Piece {

	private final Team team;
	private final Rank rank;
	private HexCoordinate position;
	private Piece next, prev;

	private Piece() {
		team = null;
		rank = null; // not normally permitted.
		next = this; // needed for dummy node
		prev = this;
	}

	/** Create a piece with the given rank.
	 * @param t team for the piece, must not be null
	 * @param r rank to use, must not be null
	 */
	public Piece(Team t, Rank r) {
		if (t == null) throw new NullPointerException("Cannot use null team");
		if (r == null) throw new NullPointerException("cannot use null rank");
		team = t;
		rank = r;
	}

	public Team getTeam() { return team; }
	public Rank getRank() { return rank; }
	public HexCoordinate getPosition() { return position; }

	/**
	 * Set the position of this piece
	 * @param h hex coordinate, may be null
	 */
	public void setPosition(HexCoordinate h) {
		position = h;
	}

	@Override
	public String toString() {
		if (rank == null) return super.toString() + "<dummy>"; 
		String loc = (position == null) ? "<>" : position.toString();
		return team + "/" + rank + loc;
	}

	/**
	 * Create a piece using the information in the string as a guide.
	 * The string should have the format generated by {@link #toString()}
	 * @param s string to use to make piece, must not be null
	 * @return new piece with that string
	 * @exception FormatException the string is badly formatted.
	 * @exception IllegalArgumentException the string has an unknown team or rank.
	 */
	public static Piece fromString(String s) {
		int slash = s.indexOf('/');
		int pos = s.indexOf('<');
		if (slash < 0 || pos < slash || !s.endsWith(">")) throw new FormatException("Not in form T/R<..>: " + s);
		Team t = Team.valueOf(s.substring(0, slash));
		Rank r = Rank.valueOf(s.substring(slash+1,pos));
		String posString = s.substring(pos);
		HexCoordinate p = posString.equals("<>") ? null : HexCoordinate.fromString(posString); 
		Piece piece = new Piece(t,r);
		piece.setPosition(p);
		return piece;
	}

	/**
	 * Draw a piece on the board.
	 * @param g graphics context, must not be null
	 * @param width hexagon width
	 */
	public void draw(Graphics g, int width) {
		if (position == null) return;
		Icon i = rank.getIcon(team,width);
		int w = i.getIconWidth();
		int h = i.getIconHeight();
		Point p = position.toPoint(width);
		i.paintIcon(null, g, p.x-w/2, p.y-h/2);
	}

	/**
	 * An endogenous collection of pieces.
	 */
	public static class Collection extends AbstractCollection<Piece> {
        
	    // the only fields:
		private final Piece dummy = new Piece();
		private int count;
		private int version;

		private static boolean doReport = true;

		private boolean report(String message) {
			if (doReport) System.out.println("Invariant error: " + message);
			return false;
		}

		private boolean wellFormed() {
		    
		    int pieceCount = 0;
		    Piece i = dummy;
		    if ((i.next == null) || (i.prev == null)) { 
		        return report("Null pointers at dummy."); 
		    }
		    if ((i.next.prev == null) || (i.next.prev != i) || (i.prev.next == null) || (i.prev.next != i)) { 
		        return report("Null or broken link at dummy."); 
		    }
            if (dummy.prev != dummy) {
                ++pieceCount;
                for (i = dummy.next; i != dummy.prev; i = i.next) {
                    if ((i.next.prev == null) || (i.next.prev != i) || (i.prev.next == null) || (i.prev.next != i)) { 
                        return report("Null or broken link at: " + i); 
                    }
                    ++pieceCount;
                }
            }
            if (pieceCount != count) { return report("count inaccurately represents list size"); }
			return true;
		}

		/**
		 * Create an empty collection.
		 */
		public Collection() {
			assert wellFormed() : "invariant failed in constructor";
		}

		@Override // required by Java
		public Iterator<Piece> iterator() {
			assert wellFormed() : "invariant failed in iterator()";
			return new MyIterator();
		}

		@Override // required by Java
		public int size() {
			assert wellFormed() : "invariant failed in size()";
			return count;
		}
		
		@Override // Not implemented by default
        public boolean add(Piece e) {
            assert wellFormed() : "invariant failed at start of add()";
            
            if (e == null) 
                throw new NullPointerException("No null pieces may be added to a list");
            
            if ((e.next != null) || (e.prev != null)) 
                throw new IllegalArgumentException("A piece cannot be a member of more than one list at a time.");
            
            if (contains(e))
                throw new IllegalArgumentException("A piece cannot appear in a single list more than once.");
            
            dummy.prev.next = e;
            e.prev = dummy.prev;
            e.next = dummy;
            dummy.prev = dummy.prev.next;
            ++count;
            ++version;
            
            assert wellFormed() : "invariant failed at end of add()";
            
            return true;
		}

        @Override
        public void clear() {
            assert wellFormed() : "invariant failed at start of clear()";
            Iterator<Piece> it = iterator();
            while (it.hasNext()) {
                it.next();
                it.remove();
            }
            assert wellFormed() : "invariant failed at end of clear()";
        }

        @Override
        public boolean contains(Object o) {
            // TODO Auto-generated method stub
            return super.contains(o);
        }

        @Override
        public boolean remove(Object o) {
            assert wellFormed() : "invariant failed at start of remove()";
            Iterator<Piece> it = iterator();
            while (it.hasNext()) {
                Piece p = it.next();
                if (p.equals(o)) {
                    it.remove();
                    assert wellFormed() : "invariant failed at end of remove()";
                    return true;
                }
            }
            return false;
        }

		// TODO: What else?

		private class MyIterator implements Iterator<Piece> {
            private Piece current;
			private boolean canRemove;
			private int myVersion;

			public MyIterator() {
				current = dummy;
				canRemove = false;
				myVersion = version;
			}

			private void checkStale() {
			    if (myVersion != version) throw new ConcurrentModificationException("This iterator is stale.");
			}

			@Override // required by Java
			public boolean hasNext() {
				checkStale();
				
				return (current.next != dummy);
			}

			@Override // required by Java
			public Piece next() {
			    checkStale();
			    
			    if (!hasNext()) throw new NoSuchElementException("Iterator exhausted");
			    
			    current = current.next;
			    canRemove = true;
			    
			    return current;
			}
			
			@Override
            public void remove() {
			    checkStale();
			    
                if (!canRemove) throw new IllegalStateException("Must call next before calling remove.");
                
                Piece p = current;
                
                p.prev.next = p.next;
                p.next.prev = p.prev;
                current = p.prev;
                p.next = null;
                p.prev = null;
                
                --count;
                canRemove = false;
                ++myVersion;
                ++version;
            }

			// TODO: what else ?
		}
	}
	
	public static class TestInvariant extends TestCase {
		private Collection self;
		private Piece ghost = new Piece();
		private Piece c[] = { null,
				new Piece(Team.GREEN,Rank.BOAT),
				new Piece(Team.BLUE,Rank.BOAT),
				new Piece(Team.RED,Rank.FOOT),
				new Piece(Team.BLUE,Rank.FOOT),
				new Piece(Team.BLUE,Rank.CAR),
				new Piece(Team.RED,Rank.CAR),	
				new Piece(Team.GREEN,Rank.HORSE),
		};
		private Piece d[] = { null, // doppelganger:
				new Piece(Team.GREEN,Rank.BOAT),
				new Piece(Team.BLUE,Rank.BOAT),
				new Piece(Team.RED,Rank.FOOT),
				new Piece(Team.BLUE,Rank.FOOT),
				new Piece(Team.BLUE,Rank.CAR),
				new Piece(Team.RED,Rank.CAR),	
				new Piece(Team.GREEN,Rank.HORSE),
		};

		@Override
		protected void setUp() {
			Collection.doReport = false;
			self = new Collection();
		}

		public void test0() {
			// self starts empty
			assertEquals(true,self.wellFormed());
			self.count = 1;
			assertEquals(false,self.wellFormed());
		}
		
		public void test1() {
			self.count = 1;
			self.dummy.next = c[1];
			assertEquals(false,self.wellFormed());
			c[1].next = self.dummy;
			assertEquals(false,self.wellFormed());
			c[1].prev = self.dummy;
			assertEquals(false,self.wellFormed());
			self.dummy.prev = c[1] = c[1];
			assertEquals(true,self.wellFormed());
			self.count = 0;
			assertEquals(false,self.wellFormed());
		}
		
		public void test2() {
			self.count = 1;
			self.dummy.next = c[1];
			c[1].next = self.dummy;
			c[1].prev = self.dummy;
			self.dummy.prev = d[1]; // duplicate piece
			d[1].next = self.dummy;
			d[1].prev = self.dummy;
			assertEquals(false,self.wellFormed());
		}

		public void test3() {
			self.count = 1;
			self.dummy.next = c[1];
			self.dummy.prev = c[1];
			c[1].next = self.dummy;
			c[1].prev = ghost;
			assertEquals(false,self.wellFormed());
			c[1].prev = self.dummy;
			c[1].next = ghost;
			ghost.prev = c[1];
			ghost.next = c[1];
			assertEquals(false,self.wellFormed());
		}
		
		public void test4() {
			self.count = 2;
			self.dummy.next = c[3];
			c[3].next = c[4];
			c[4].next = self.dummy;
			assertFalse(self.wellFormed());
			c[4].prev = c[3];
			assertFalse(self.wellFormed());
			c[3].prev = self.dummy;
			assertFalse(self.wellFormed());
			self.dummy.prev = c[3];
			assertFalse(self.wellFormed());
			self.dummy.prev = c[4];
			assertTrue(self.wellFormed());
		}

		public void test5() {
			self.count = 3;
			self.dummy.next = c[1];
			c[1].next = c[2];
			c[2].next = c[1];
			c[1].prev = c[2];
			c[2].prev = c[1];
			self.dummy.prev = c[3];
			c[3].prev = c[2];
			c[3].next = self.dummy;
			assertFalse(self.wellFormed());
			c[1].prev = self.dummy;
			assertFalse(self.wellFormed());
			c[2].next = c[3];
			assertTrue(self.wellFormed());
		}

		public void test6() {
			self.count = 4;
			self.dummy.next = c[1];
			c[1].next = c[2]; 
			c[2].next = c[3]; 
			c[3].next = c[4];
			c[4].next = self.dummy;
			self.dummy.prev = c[4];
			c[4].prev = d[3]; d[3].next = c[4]; d[3].prev = d[2];
			c[3].prev = d[2]; d[2].next = c[3]; d[2].prev = d[1];
			c[2].prev = d[1]; d[1].next = c[2]; d[1].prev = self.dummy;
			c[1].prev = ghost; ghost.next = c[1]; ghost.prev = c[4];
			assertFalse(self.wellFormed());
			c[1].prev = self.dummy;
			assertFalse(self.wellFormed());
			c[2].prev = c[1];
			assertFalse(self.wellFormed());
			c[3].prev = c[2];
			assertFalse(self.wellFormed());
			c[4].prev = c[3];
			assertTrue(self.wellFormed());
		}

		public void test7() {
			self.count = 4;
			self.dummy.next = c[1];
			c[1].next = c[2]; 
			c[2].next = c[3]; 
			c[3].next = c[4];
			c[4].next = self.dummy;
			self.dummy.prev = c[4];
			c[4].prev = c[3];
			c[3].prev = c[2];
			c[2].prev = c[1];
			c[1].prev = self.dummy;
			assertTrue(self.wellFormed());
			c[3].next = c[1];
			assertFalse(self.wellFormed());
			c[3].next = c[2];
			assertFalse(self.wellFormed());
			c[3].next = c[3];
			assertFalse(self.wellFormed());
		}

		public void test8() {
			self.count = 0;
			self.dummy.next = self.dummy.prev = null;
			assertFalse(self.wellFormed());
		}

		public void test9() {
			self.count = 3;
			self.dummy.next = c[1]; c[1].prev = self.dummy;
			c[1].next = c[2]; c[2].prev = c[1];
			c[2].next = c[3]; c[3].prev = c[2];
			c[3].next = null; self.dummy.prev = c[3];
			assertEquals(false,self.wellFormed());
		}
	}

}
